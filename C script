#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define SIZE 100

/* Word categories */
typedef enum
{
    greeting,
    gratitude,
    food,
    drink,
    dessert,
    spicy,
    special,//diabetic, celiaco, vegetarian, etc
    size,
    location,
    payment
} categories;

/* Linked List with the word and its category */
typedef struct node_s
{
    char word[20];
    categories topic;
    struct node_s *p_next;
} node_t;


void get_option(char *option);
int read_sentence(char message[SIZE]);// change word to lower case
int read_word(char sentence[SIZE], char words[SIZE][SIZE]); 
int show_options(char reply[SIZE]);
int send_reply(char reply[SIZE]);
void get_order();
void del_stop_words(char words[SIZE][SIZE], int num_words, char clean_words[][SIZE]);//returns the number of words *categorizeds*
// for reply, put a random num to pick a random answer from a answer pool
int load_vocab(node_t **pp_head, char vocfile[10]);




int main(void)
{
    char sentence[SIZE];//either sentence or word
    char words[SIZE][SIZE];
	char clean_words[SIZE][SIZE];
	char reply[SIZE];
	char if_help[SIZE]= "Did the program help?(y/n)";
	char location[SIZE]= "we're in Escazu.";
    int n, wcount; //count of the number of words stored in words[SIZE][SIZE]
	char *option;
	char *quit;
    //Maybe include msg count? to know what to do at which time.
    
	// delete first message
	read_sentence(sentence);
	
	do
	{
		show_options(reply);
		get_option(option);
		
		switch(*option)
		{
			case 'A': //location of the shop
			case 'a':
				send_reply(location); //	verbal address or maybe a link of waze, google maps
				break;
				
			case 'B': //Menu of the shop
			case 'b':
				//send_reply(????);  send link of menu 
				break;
				
			case 'C': // when does shop open and close?
			case 'c':
				//send_reply(????);  send the opening and closing time
				break;
				
			case 'D': // Further questions (ask a question to our chat bot)
			case 'd':
				read_sentence(sentence);
				//find sentence category, if was not successful, read words
				
				
				break;
		}
		
		send_reply(if_help);
		get_option(quit);
	}while(quit == "n");
    

	return 0;
}

int read_sentence(char message[SIZE])
{
    FILE *input;//Jona: put the file inside the function
    char line[SIZE];
    int i, countl = 0;//helper, count line
    char *sts;//status: pointer to line string if succesful, else NULL
    
    input = fopen("client_msg.txt","r");
    
    if (input == NULL)
    {
        printf("Couldn't open file");
        return -1;
    }
    
    do
    {
    	sts = fgets(line, SIZE, input);//extract the whole sentence out of the file
    }while(sts == NULL);//keep scanning until there is a message
    
    while (sts != NULL)
    {
        countl++;
        if (line[strlen(line) - 1] == '\n') 
       {
            line[strlen(line) - 1] = ' ';
       }
       
       //first line will be stored within the message string
       if (countl == 1)
       {
           strcpy(message, line);
       }
       else//else, concatenate to message
       {
            strcat(message, line);
       }
       
       sts = fgets(line,SIZE,input);
    }
    
	// after all that, turn the string to lower case to make it easy to operate
	for(i = 0; i < strlen(message); i++)
	{
		if(message[i] > 64 && message[i] < 91)
		{
			message[i] = message[i] + 32;
		}
	}
    //Remember to delete the input from the file after it was read! 
    input = fopen("client_msg.txt","w");
    fclose(input);
    return 0;
}

int read_word(char sentence[SIZE], char words[SIZE][SIZE]) // function from string lecture modified by William.
{
	char typed_letter;
	int is_space_or_punctuation;
	int in_word;
	int dst_letter_idx;
	int dst_word_idx;
	int i;
	
	in_word = 0;
	dst_word_idx = 0;
	dst_letter_idx = 0;
    
	for (i = 0; i < strlen(sentence); i++)
	{
		/* Get a letter */
		typed_letter = sentence[i];
		
		/* Check if it is a space or punctuation */
		is_space_or_punctuation = (typed_letter == ' ' || typed_letter == ',' || typed_letter == '.' || typed_letter == '\n' || typed_letter == '!' || typed_letter == '?');
		
		if (!in_word)
		{
			/* We are searching for the word beginning */
			if (!is_space_or_punctuation)
			{
				/* Found the beginning of a word */
				/* Copy the letter */
				words[dst_word_idx][dst_letter_idx] = typed_letter;
				dst_letter_idx++;
				
				in_word = 1;
			}
		}
		else
		{
			/* We are in the middle of a word */
			
			if (!is_space_or_punctuation)
			{
				/* Copy the letter, but only if it fits */
				if (dst_letter_idx < (SIZE-1) )
				{
					words[dst_word_idx][dst_letter_idx] = typed_letter;
					dst_letter_idx++;
				}
			}
			else
			{
				/* This is the end of the word */
				
				/* Terminate the string for the current word */
				words[dst_word_idx][dst_letter_idx] = '\0';
				
				/* Move to the next word index */
				dst_word_idx++;
				dst_letter_idx = 0;
				if (dst_word_idx == SIZE)
				{
					/* No space for more words */
					break;
				}
				
				/* Start search mode */
				in_word = 0;
			}
		}	
	}
    //Jonathan: it returns the number of words found
    return dst_word_idx+1;
}

//Get order (this should be a category) function to store info in a CSV file (William)
void get_order()
{
	FILE *input;
	FILE *output;
	FILE *order;
	int question_counter = 5;//number of questions
	int i;
	char info[SIZE];
	
	for(i = 1; i < question_counter; i++)
	{
		output = fopen("output_msg.txt","w"); //everytime we open the file with writing mode, it erases what was inside
		
		switch(i) //ask questions
		{
			case 1:
				fprintf(output,"What's your name? ");
				break;
			case 2:
				fprintf(output,"What's your phone number? ");
				break;
			case 3:
				fprintf(output,"Place your order please: ");
				break;
			case 4:
				fprintf(output,"What is the address? ");
				break;
		}
		
		fclose(output);//close file
		
		//wait until the client replies (maybe with sts)
		read_sentence(info);//reads the client's response and stores it in the string info
		
		//opens csv file and stores the information in it
		order = fopen("order.csv","a");
		fprintf(order,"%s,",info);
		
	}
	
	fprintf(order,"\n");// put a new line so that every order will be separated
	
}

//show menu de opciones (show menu, order food: store in a CSV file for all the info, QA with the bot).
int show_options(char reply[SIZE])
{
    //Se puede modificar luego
    strcpy(reply, "Hello! to see our menu enter A, to order enter B, for bot assistance enter C");
    send_reply(reply);
    
    return 0;
}

// gets the option that the user wants
void get_option(char *option)
{
	FILE *input;
	
	input = fopen("client_msg.txt","r");
	
	// wait till user writes(with sts)
	do
	{
		*option = getc(input);// gets the character from the file
		
	}while(*option == EOF); 
	
	fclose(input);
	
	input = fopen("client_msg.txt","w");
    fclose(input);//deletes what was in the file
}
//find_sentence_category(string); (categorization)
//find_word_category(word);--> helpers are the delete stop words, find root, read word.

//reply sentence based on category
//reply word based on category

//Sends the message so the python script can send it (we originally called it store_reply)
int send_reply(char reply[SIZE])
{
    FILE *output;
    output = fopen("output_msg.txt","w");
    
    if (output == NULL)
    {
        printf("Couldn't open file");
        return -1;
    }
    
    fprintf(output, "%s", reply);
    
    fclose(output);
    
    return 0;
}


void del_stop_words(char words[SIZE][SIZE], int num_words, char clean_words[SIZE][SIZE]) // Minoli
{
    char stop[55][SIZE] = {"the", "about", "once", "during", "out", "very", "having", "with", "they", "while", "on", "he", "hers", "she", "own", "an", "have", "nor" , "not", "this", "both", "because", "too", "only", "myself", "me", "it", "here", "than", "whom", "who", "if", "my", "how", "those", "i", "can", "did", "a", "but", "by", "off", "does", "on", "we", "so", "our", "now", "before", "can", "more", "ourselves", "above", "up", "all"};
    int x,y;
	int not_stop = 0;
	int clean_idx = 0;
	
	for(x = 0;x < num_words; x++)
	{
		not_stop = 0;
		for(y = 0; y < 55; y++)
		{
			if( strcmp( words[x], stop[y]) == 0 )
			{
				not_stop = 1;
			}
		}
		if( not_stop == 0)
		{
			strcpy(clean_words[clean_idx],words[x]);
			clean_idx++;
		}
	}
 
}


int load_vocab(node_t **pp_head, char vocfile[20])//string containing the name of the file
{
    FILE *vocab;
    char letter;
    char token[20];//start as an empty string
    int token_idx = 0;
	int i;
    node_t *p_node; //helper node
    
    vocab = fopen(vocfile,"r");
    
    if (vocab == NULL)
    {
        printf("Couldn't open file");
        return -1;
    }
    
    
    
    //read letter, get until a ',' or '\n'
    while (1)
    {
        //note: new lines will be omitted
        letter = fgetc(vocab);
        
        if (letter >= 'a' && letter <= 'z')
        {
            //append each letter to the token
            token[token_idx] = letter;
            token_idx++;
        }
        else if (letter == ',')
        {
             //setup some space
			p_node = malloc(sizeof(node_t));
			//check for failure
			if (p_node == NULL)
			{
				printf("Error, no space could be assigned to node.");
				return -1;
			}
			//end of the token
            token[token_idx] = '\0';
            //store word and number as category
            strcpy(p_node->word,token);
            //printf("%s\n", p_node->word);//fix this
            
            //read one more and save that number
            letter = fgetc(vocab);
            i = atoi(&letter);
            p_node->topic = i;
            //printf("%d\n", p_node->topic);
            //storing nodes each time at the end of the list.
            p_node->p_next = *pp_head;
            //logic to adding nodes at the end: based on code of the ppt 7 on linked lists
            //if the list is empty, point the head to it
            *pp_head = p_node;
            
            token_idx = 0;
        }
        //end of the file
        else if (letter == EOF)
        {
            break;
        }
    }
 
    return 0;
}
