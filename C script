#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define SIZE 100

void get_option(char *option);
int read_sentence(char message[SIZE]);// change word to lower case
int read_word(char sentence[SIZE], char words[SIZE][SIZE]); 
int show_options(char reply[SIZE]);
int send_reply(char reply[SIZE]);
void get_order();
void del_stop_words(char words[SIZE][SIZE], int num_words, char clean_words[][SIZE]);//returns the number of words *categorizeds*
//enums are categories!!

int main(void)
{
    char sentence[SIZE];//either sentence or word
    char words[SIZE][SIZE];
	char clean_words[SIZE][SIZE];
	char reply[SIZE]
	char if_help = "Did the program help?(y/n)";
    int n, wcount; //count of the number of words stored in words[SIZE][SIZE]
	char option;
	char quit = "n";
    //Maybe include msg count? to know what to do at which time.
    
	// delete first message
	read_sentence(sentence);
	
	do
	{
		show_options(reply);
		get_option(option);
		
		switch(option)
		{
			case "A": //location of the shop
			case "a":
				send_reply(????); //verbal address or maybe a link of waze, google maps
				break;
				
			case "B": //Menu of the shop
			case "b":
				send_reply(????); // send link of menu 
				break;
				
			case "C": // when does shop open and close?
			case "c":
				send_reply(????); // send the opening and closing time
				break;
				
			case "D": // Further questions (ask a question to our chat bot)
			case "d":
				read_sentence(sentence);
				//find sentence category, if was not successful, read words
				
				
				break;
		}
		
		send_reply(if_help);
		get_option(quit);
	}while(quit == "n");
    

	return 0;
}

int read_sentence(char message[SIZE])
{
    FILE *input;//Jona: put the file inside the function
    char line[SIZE];
    int i, countl = 0;//helper, count line
    char *sts;//status: pointer to line string if succesful, else NULL
    
    input = fopen("client_msg.txt","r");
    
    if (input == NULL)
    {
        printf("Couldn't open file");
        return -1;
    }
    
    do
    {
    	sts = fgets(line, SIZE, input);//extract the whole sentence out of the file
    }while(sts == NULL);//keep scanning until there is a message
    
    while (sts != NULL)
    {
        countl++;
        if (line[strlen(line) - 1] == '\n') 
       {
            line[strlen(line) - 1] = ' ';
       }
       
       //first line will be stored within the message string
       if (countl == 1)
       {
           strcpy(message, line);
       }
       else//else, concatenate to message
       {
            strcat(message, line);
       }
       
       sts = fgets(line,SIZE,input);
    }
    
    //Jonathan: Remember to delete the input from the file after it was read! 
    input = fopen("client_msg.txt","w");
    fclose(input);
    return 0;
}

int read_word(char sentence[SIZE], char words[SIZE][SIZE]) // function from string lecture modified by William.
{
	char typed_letter;
	int is_space_or_punctuation;
	int in_word;
	int dst_letter_idx;
	int dst_word_idx;
	int i;
	
	in_word = 0;
	dst_word_idx = 0;
	dst_letter_idx = 0;
    
	for (i = 0; i < strlen(sentence); i++)
	{
		/* Get a letter */
		typed_letter = sentence[i];
		
		/* Check if it is a space or punctuation */
		is_space_or_punctuation = (typed_letter == ' ' || typed_letter == ',' || typed_letter == '.' || typed_letter == '\n' || typed_letter == '!' || typed_letter == '?');
		
		if (!in_word)
		{
			/* We are searching for the word beginning */
			if (!is_space_or_punctuation)
			{
				/* Found the beginning of a word */
				/* Copy the letter */
				words[dst_word_idx][dst_letter_idx] = typed_letter;
				dst_letter_idx++;
				
				in_word = 1;
			}
		}
		else
		{
			/* We are in the middle of a word */
			
			if (!is_space_or_punctuation)
			{
				/* Copy the letter, but only if it fits */
				if (dst_letter_idx < (SIZE-1) )
				{
					words[dst_word_idx][dst_letter_idx] = typed_letter;
					dst_letter_idx++;
				}
			}
			else
			{
				/* This is the end of the word */
				
				/* Terminate the string for the current word */
				words[dst_word_idx][dst_letter_idx] = '\0';
				
				/* Move to the next word index */
				dst_word_idx++;
				dst_letter_idx = 0;
				if (dst_word_idx == SIZE)
				{
					/* No space for more words */
					break;
				}
				
				/* Start search mode */
				in_word = 0;
			}
		}	
	}
    //Jonathan: it returns the number of words found
    return dst_word_idx+1;
}

//Get order (this should be a category) function to store info in a CSV file (William)
void get_order()
{
	FILE *input;
	FILE *output;
	FILE *order;
	int question_counter = 5;//number of questions
	int i;
	char info[SIZE];
	
	for(i = 1; i < question_counter; i++)
	{
		output = fopen("output_msg.txt","w"); //everytime we open the file with writing mode, it erases what was inside
		
		switch(i) //ask questions
		{
			case 1:
				fprintf(output,"What's your name? ");
				break;
			case 2:
				fprintf(output,"What's your phone number? ");
				break;
			case 3:
				fprintf(output,"Place your order please: ");
				break;
			case 4:
				fprintf(output,"What is the address? ");
				break;
		}
		
		fclose(output);//close file
		
		//wait until the client replies (maybe with sts)
		read_sentence(info);//reads the client's response and stores it in the string info
		
		//opens csv file and stores the information in it
		order = fopen("order.csv","a");
		fprintf(order,"%s,",info);
		
	}
	
	fprintf(order,"\n");// put a new line so that every order will be separated
	
}

//show menu de opciones (show menu, order food: store in a CSV file for all the info, QA with the bot).
int show_options(char reply[SIZE])
{
    //Se puede modificar luego
    strcpy(reply, "Hello! to see our menu enter A, to order enter B, for bot assistance enter C");
    send_reply(reply);
    
    return 0;
}

// gets the option that the user wants
void get_option(char *option)
{
	FILE *input;
	
	input = fopen("client_msg.txt","r");
	
	// wait till user writes(with sts)
	*option = getc(input); // gets the character from the file
	fclose(input);
	
	input = fopen("client_msg.txt","w");
    fclose(input);//deletes what was in the file
}
//find_sentence_category(string); (categorization)
//find_word_category(word);--> helpers are the delete stop words, find root, read word.

//reply sentence based on category
//reply word based on category

//Sends the message so the python script can send it (we originally called it store_reply)
int send_reply(char reply[SIZE])
{
    FILE *output;
    output = fopen("output_msg.txt","w");
    
    if (output == NULL)
    {
        printf("Couldn't open file");
        return -1;
    }
    
    fprintf(output, "%s", reply);
    
    fclose(output);
    
    return 0;
}

/**************** del_stop_words function ************************/
int del_stop_words(char words[SIZE][SIZE], int num_words, char clean_words[SIZE][SIZE]) // Minoli
{
    char stop[55][SIZE] = {"the", "about", "once", "during", "out", "very", "having", "with", "they", "while", "on", "he", "hers", "she", "own", "an", "have", "nor" , "not", "this", "both", "because", "too", "only", "myself", "me", "it", "here", "than", "whom", "who", "if", "my", "how", "those", "i", "can", "did", "a", "but", "by", "off", "does", "on", "we", "so", "our", "now", "before", "can", "more", "ourselves", "above", "up", "all"};
    int x,y;
	int not_stop = 0;
	int clean_idx = 0;
	
	for(x = 0;x < num_words; x++)
	{
		not_stop = 0;
		for(y = 0; y < 55; y++)
		{
			if( strcmp( words[x], stop[y]) == 0 )
			{
				not_stop = 1;
			}
		}
		if( not_stop == 0)
		{
			strcpy(clean_words[clean_idx],words[x]);
			clean_idx++;
		}
	}
 
    return 0;
}
